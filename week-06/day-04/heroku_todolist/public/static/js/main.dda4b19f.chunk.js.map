{"version":3,"sources":["todolist.module.css","delete.svg","undone.svg","done.svg","todolist.js","serviceWorker.js","index.js"],"names":["module","exports","require","config","TodoList","state","domain","process","PORT","addIssue","bind","setIssue","deleteIssue","console","log","this","fetch","then","response","json","data","setState","copyState","Object","key","inputIssue","document","getElementsByClassName","value","length","alert","deepCopyState","keys","newIndex","Number","Id","Text","Done","jsonIssue","method","headers","body","JSON","stringify","error","event","setId","target","id","split","deleteId","className","type","onClick","map","issue","todoListStyle","issueLine","iconContainer","src","deleteIcon","alt","doneIcon","undoneIcon","React","Component","Boolean","window","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.dda4b19f.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"deleteIcon\":\"todolist_deleteIcon__1V38N\",\"doneIcon\":\"todolist_doneIcon__ognRv\",\"issueLine\":\"todolist_issueLine__2VZsG\",\"iconContainer\":\"todolist_iconContainer__3jOnb\"};","module.exports = __webpack_public_path__ + \"static/media/delete.58211f8a.svg\";","module.exports = __webpack_public_path__ + \"static/media/undone.692ad39f.svg\";","module.exports = __webpack_public_path__ + \"static/media/done.ff0745b9.svg\";","import React from 'react';\n\nimport deleteIcon from './delete.svg';\nimport undoneIcon from './undone.svg';\nimport doneIcon from './done.svg';\nimport todoListStyle from './todolist.module.css';\n\nrequire('dotenv').config();\n\nclass TodoList extends React.Component {\n    constructor() {\n        super();\n        this.state = {};\n        this.domain = `http://localhost:${process.env.PORT}/api/todos`;\n        this.addIssue = this.addIssue.bind(this);\n        this.setIssue = this.setIssue.bind(this);\n        this.deleteIssue = this.deleteIssue.bind(this);\n    }\n\n    componentWillMount() {\n        console.log(this.domain);\n        fetch(this.domain)\n            .then(response => response.json())\n            .then(data => { this.setState(data) });\n    }\n\n    deepCopyState() {\n        let copyState = new Object();\n        for (let key in this.state) {\n            copyState[key] = this.state[key];\n        }\n        return copyState;\n    }\n\n    addIssue() {\n        let inputIssue = document.getElementsByClassName('input-box')[0].value;\n        if (inputIssue.length < 3) {\n            alert(\"issue name must be longer than 3 characters!\");\n            document.getElementsByClassName('input-box')[0].value = '';\n            return;\n        }\n        let copyState = this.deepCopyState();\n        const keys = Object.keys(this.state);\n        const newIndex = Number(keys[keys.length - 1]) + 1;\n        copyState[newIndex] = {\n            Id: newIndex,\n            Text: inputIssue,\n            Done: 0\n        }\n        this.setState(copyState);\n        const jsonIssue = {\n            'text': inputIssue\n        }\n        try{\n            fetch(this.domain, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify(jsonIssue)\n            })\n        } catch(error) {\n            console.log(error);\n        }\n    }\n\n    setIssue(event) {\n        let copyState = this.deepCopyState();\n        const setId = event.target.id.split(' ')[0];\n        copyState[setId]['Done'] = !this.state[setId]['Done'];\n        this.setState(copyState);\n    }\n\n    deleteIssue(event) {\n        // const deleteId = Number(event.target.id.split(' ')[0]);\n        // let copyState = new Object;\n        // Object.keys(this.state).forEach(key => {\n        //     if (this.state[key]['Id'] !== Number(deleteId)) {\n        //         copyState[key] = new Object;\n        //         Object.keys(this.state[key]).forEach(okey => {\n        //             copyState[key][okey] = this.state[key][okey];\n        //         });\n        //     }\n        // });\n        // this.setState(copyState);\n        const deleteId = Number(event.target.id.split(' ')[0]);\n        delete this.state[deleteId];\n        this.setState(this.state);\n        try {\n            fetch(this.domain + `/${deleteId}`, {\n                method: 'DELETE',\n                headers: {\n                    'Content-Type': 'application/json',\n                }\n            });\n        } catch (error) {\n            console.log(error);\n        }\n    }\n\n    render() {\n        return (\n            <>\n                <div className=\"input-container\">\n                    <input type=\"text\" className=\"input-box\" />\n                    <button type=\"submit\" className=\"input-button button-text\" onClick={this.addIssue}>Add</button>\n                </div>\n                <ul className=\"list-container todo-item\">\n                    {Object.keys(this.state).map(issue =>\n                        <li className={todoListStyle.issueLine} key={issue}>{this.state[issue].Text}\n                            <div className={todoListStyle.iconContainer}>\n                                <img src={deleteIcon} className={todoListStyle.deleteIcon} onClick={this.deleteIssue} id={issue + ' delete'} alt='delete icon' />\n                                <img src={this.state[issue].Done ? doneIcon : undoneIcon} className={todoListStyle.doneIcon} onClick={this.setIssue} id={issue + ' done'} alt='finish icon' />\n                            </div>\n                        </li>\n                    )}\n                </ul>\n            </>\n        );\n    }\n}\n\nexport default TodoList;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport TodoList from './todolist';\nimport './index.css';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<TodoList />, document.getElementsByClassName('todolist-container')[0]);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}